using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _10.Sort
{
    //1 선형정렬 3종 구현 원리 조사
    /* 1. 선택정렬
     * 선택정렬의 경우 정렬되지않은 데이터들에 대해 가장 작은데이터를 찾아 가장 앞의 데이터와 교환해나가는 방식이다.
     * 수행은 다음과정을 따른다  
     * (1) 해당 배열내에서 최소값을 찾는다 (탐색과정)
     * (2) 찾은 최소값을 맨앞의 값과 교체한다 (swap 과정)
     * (3) 교체한 맨 앞의 데이터는 정렬된것으로 간주하고 다음인덱스부터 1, 2 과정을 반복한다.
     * 선택정렬의 경우 구현은 단순하지만, 매우 비효율적이다.
     * 하나의 인덱스를 고정하기위해서 모든수를탐색하고 비교까지 이루어져야하므로 정렬시간에 비효율적인 O(n^2)값을 가진다.
     * 
     * 2. 삽입정렬
     * 삽입정렬의경우 배열내의 값을 하나씩 꼽아서 자신의 왼쪽 데이터들에 대해 자신의왼쪽엔 작은수 오른쪽엔 큰수가 오도록 적절한위치에 집어넣고 이를 반복한다.
     * 수행과정은 다음과정을 따른다.
     * (1) 첫번쨰 인덱스는 넘어가고 두번째인덱스부터 왼쪽값과 비교
     * (2) 왼쪽값중에 자기보다 작은수가나올떄까지 배열의 요소를 교체해준다.
     * (3) 해당과정을 배열의 끝까지 반복한다.
     * 삽입정렬의경우 정렬이 잘되어 있는 경우에 최적 Big-O(n)값을 가진다 (각원소별 한번씩만 비교를 하면됨) 최악의경우 n^2의 값을가짐.
     * 
     * 3. 버블정렬
     * 인접한 두 원소를 비교하여 정렬하는 방법이다.
     * 단순하게 A>B라는 조건식을 사용하여 회전마다 위치를 바꾸어가므로 구현이 매우 간단하다.
     * 수행은 다음과정을 따른다
     * (1)처음인덱스값과 두번째인덱스값의 비교를하고 조건식을 만족할경우 SWAP해준다
     * (2)두번째와 세번째, 세번째와 네번째 등 배열의 끝까지 비교하면서 자료를 바꿔준다.
     * (3)이 경우에 마지막 데이터는 정렬이 된것으로 간주하며, 해당과정을 배열의 개수-1만큼 반복한다.
     * 버블정렬또한 구현은 단순하지만 , 매우 비효율적이다.
     * 배열의 상태와 상관없이 최적/최악 모두 O(n^2)의 값을 가지게된다. 특히나 요소의 이동이 많이일어나기때문에 오버헤드량이늘어날수있다.
     */

    //2 복합정복정렬 3종 구현원리 조사 및 특징
    /* 1. 힙정렬
     * 불안정정렬인 힙정렬의 경우 완전 이진트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조이다. 최댓값 최솟값 추출에 매우빠른 효율성을 가진다.
     * 해당 이진정렬을 활용한 힙정렬(heap sort)알고리즘의 경우 최대힙트리나 최소힙트리를 구성해 (내림차순,오름차순)정렬을한다.
     * 수행은 다음과정을 따른다.
     * (1) 정렬해야할 n개의 요소들로 힙(완전이진트리)형태를 만든다.
     * (2) 이후 한번에 하나씩요소를 힙에서 꺼내서(root node) 배열에 정렬한다.
     * (3) 최대힙을 가정한후 배열의 마지막요소와 스왑을할경우 오름차순정렬이됨. 최소힙의 경우는 내림차순정렬
     * 힙정렬의 경우 이진트리의 (logn)의 Big-O를 n번 수행하므로 결과적으로 (nlogn)의 효율을 가지게 된다.
     * 
     * 
     * 2. 병합정렬(합병정렬 merge sort)
     * 안정정렬에 속하며 분할정복 알고리즘의 하나이다. 분할정복의경우 단순하게 문제를 작은 두개의 문제로 분리하고 각각을 해결하고 원래의문제를 해결하는 과정이다.
     * (1) 배열을 두 부분으로 나눈다(절반/절반) 이후 나뉜 부분이 최소값(1~2)에 도달할경우 조건에따라 정렬을 해준다.
     * (2) 이후 정렬된 두부분을 합치는 과정을 반복한다.
     * 병합정렬의경우 안정된 정렬이지만 분할되어있는 부분의 데이터를 저장하고있어야하므로 추가적인 메모리소모(리스트 또는 배열)가 필요하다.
     * 장점의경우 데이터의 분포에 대한 영향을 덜받는다 -> 어떤 자료형이 들어오든지 O(nlogn)으로 동일.
     *
     * 3. 퀵정렬(Quick Sort)
     * 불안정 정렬에 속하며. 퀵정렬의경우 분할정복알고리즘의 하나로 평균적으로 매우빠른 수행속도를 자랑한다. 
     * (1) 리스트안의 한요소를 선택한다 (pivot)
     * (2) 피벗 이후부터 인덱스를 가리키는 i를 지정하고 배열의 끝부터 j를 지정한후 i는 피벗보다 큰요소를 만날때까지 한칸씩이동 j는 피벗보다 작은요소를 만날때까지 왼쪽으로이동한다.
     * (3) 두경우다 조건을 만족할경우 만족하는 두 항목을 스왑해준다
     * (4) 해당 피벗을 기준으로 양쪽을 분할하고 해당과정을 반복해준다.
     * 퀵정렬의 경우 추가적인 메모리의 소모가 적으면서 ,평균적으로 가장 빠른 속도를 보여주기에 높은 사용율을 가지며
     * 최적의 경우에 (처음 피벗이 리스트의 값의 절반을 나눌때) nlogn / 최악의경우 n^2의 효율을 보여준다.
     * 
    */
    internal class Class1
    {

    }
}