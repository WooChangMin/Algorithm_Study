using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _08.HashTable
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;

    namespace _DataStructure
    {
        /*
         * 2. 해시와 해시알고리즘
         * 
         * <2-1 해싱>
         * 해싱이라는것은 데이틀 최종사용자가 원문을 추정하기힘든 더 작고, 뒤섞인 조각으로 바꾸는것을 의미한다.
         * 이후 해시테이블이라는 매우큰 공간을 미리 할당해놓고 해시함수에 의해 바뀐 어드레스로 각각의 키에 접근을 하여
         * 데이터를 입력해주고 이후에 키값을 입력받았을때 해당 값을 출력하고 열람하기 유용하게 만들어 둔다.
         * 암호화로 비슷하게 생각할수 있지만. 해싱알고리즘의 경우 해시된 데이터를 원문의 데이터로 바꾸는것을
         * 허용하지 않는다는 점에서 차이가있다. 그러므로 해싱 과정을 거칠경우 암호저장, 무결성입증, 등등 사용이 가능하다.
         * 
         * 
         *<2-2 이상적인 해시 알고리즘이란? (효율이좋고, 해싱 자체의 의미를 확실하게 부여해주어야 함)>
         * 
         * (1) 단방햠 함수로 작용한다 : 원본데이터 -> 해싱데이터 는 지원을 하지만 반대로의 함수는 지원하면 안된다.
         * 
         * (2) 해시함수는 매우 빨리 연산을 할수 있어야 한다 : 애초에 C# 에서는 대용량 데이터를 저장하고 보관하는데에
         * 해시테이블을 사용하는데 데이터를 넣을때마다 시간이걸리거나 혹은 저장할때 많은 시간을소요한다면 효율적이지 못하다.
         * 
         * (3) 해시함수의 결과값은 충돌이 일어나지 않아야한다 : 불가능하지만, 이상적인 해시알고리즘을 구현했다는 가정하에 충돌이 없어야
         * 충돌 구현에 대한 추가적인 처리가 필요가 없다.
         * 
         * (4) 한 입력변수의 출력값은 시점과, 사용횟수에 상관없이 동일하다 : 매개변수 즉 KEY값으로 호출된 해시함수의경우
         * 시간과 공간 / 시점과 유저의 차이에 관계없이 무조건 같은 값만을 내놓아야 키를 알고있는 유저가 자료를 사용하고 처리하기 편함.
         * 
         * 
         * <해싱함수의 종류>
         * (1)계산법     : 해시코드의 표기보다 큰 수 중에서 가장 작은 소수로 나눈 나머지를 홈 주소롤 삼는 방식이다.
         * (2)제곱법     : 레코드키값을 제곱한후 그 중간 부분의 값을 홈 주소로 삼는 방식이다.
         * (3)폴딩법     : 레코드기값을 여러부분으로 나눈후 각 부분의 값을 더하거나 XOR한 값을 홈 주소로 삼는 방식이다(자릿수덧셈?)
         * (4)기수변환법 : 키숫자의 진수를 다른 진수로 변환시켜 주소크기를 절단한 높은 자릿수를 절단하고 이를 다시 주소에맞게 조정.
         * .etc....
         * 
         * 
         * <해시테이블의 충돌과 충돌해결방안>
         * <충돌>
         * 해시테이블의 경우 이상적인 해시함수의 구현이 매우 어렵기 때문에 키 값이 다르더라도 같은 해시값을 가지는 경우가
         * 종종 생긴다. 이경우 자료구조나 알고리즘의 효율성을 떨어트린다 (오버헤드 증가/ 무결성 감소등.) 그러므로 충돌관리에 대한 작업이 필수적이다.
         * 
         * 
         * <충돌을 줄이는 법>
         * (1) 첫째로 해시테이블의 크기를 매우 키우면 된다. : 테이블자체의 길이가 길어질수록 같은값을 가리킬 확률자체가 줄어들게된다
         * (2) 이상적인 해시함수를 구현해준다. : 입력값의 크기가 매우크다면 불가능에 가깝다
         * 
         * 
         * <충돌 대처>
         * (1) 체이닝 : 해시충돌이 발생햇을때 해당 레코드키에 연결리스트를 사용하여 노드형식으로 다음 주소값을 가리켜서 연결을 해둠
         *      장점 : 연결리스트만 사용하면되므로 복잡한 계산식을 사용할 필요가 없다.
         *             해시테이블이 채워질수록, 성능저하가 선형적으로 발생한다 < 오버헤드가 적다      
         * 
         * (2)개방주소법 : 해시 충돌이 일어날경우 해시테이블의 다른 빈공간에 저장을 하는 방식.
         *      -> 선형탐색 : 해시충돌시 다음 위치, 혹은 몇개를 건너뛰어 삽입    
         *      -> 제곱탐색 : 해시충돌시 제곱만큼 건너뛴 위치에 데이터를 삽입. (1,4,9,16)    
         *      -> 이중해시 : 해시충돌시 다른 해시함수를 한번더 적용한 결과를 이용한다.    
         *      장점 : 체이닝처럼 주소값이 필요가없고, 해시데이터 외에 추가적인 저장공간도 필요가없다.
         *           : 삽입 삭제시 오버헤드가 적다
         *           : 저장하려는 데이터의 값의 개수가 적을떄 유용하다(값이많을경우 오버헤드가 커질수있음) 
         */
        internal class HashSearch
        {
        }
    }
}
