namespace _08.HashTable
{
    internal class Program
    {

        /******************************************************
		 * 해시테이블 (HashTable)
		 * 
		 * 키 값을 해시함수로 해싱하여 해시테이블의 특정 위치로 직접 엑세스하도록 만든 방식
		 * 해시 : 임의의 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑
		 ******************************************************/


        // <해시테이블의 시간 복잡도>
        //  접근   탐색     삽입     삭제                    //삽입삭제가 많이일어나는경우 리스트사용하고 해시는 대용량저장공간에 유용함
        //   x     O(1)     O(1)     O(1)

        // 배열기반으로 매우 큰 데이터 자료구조를 만들어 둠 .
        // 이후 Key값을 받아(숫자나 문자나 열거형등) 해싱을 통해서 특정숫자로 바꾸어서
        // 해당 숫자에 해당하는 인덱스의 배열 위치에 값을 넣어줌.
        // 해싱 : 키값을 인덱스로 바꿈.. 키 -> 인덱스 해주는 함수를 해싱함수.
        // 공간을 포기하고 속도를 선택함.. 저장소의 공간적 손해가 필연적으로 생길수밖에없음

        // 해시함수의 조건!
        // 1. 일대일 대응 => 키-> 해시함수를 거친경우 항상 같은 인덱스가 나와야한다 : 입력에 대한 해시함수의 결과가 항상 동일해야함.

        // <해시함수의 효율>
        // 1. 해시함수 자체가 느린경우 의미가 없다. < 매우 빨라야 의미가 있음
        // 2. 해시함수의 결과가 밀집도가 낮아야 한다.
        // 3. 해시테이블의 크기가 클수록 겹치지않을확률이 높으므로 효율이 좋다.

        // <해시테이블 주의점 - 충돌>
        // 해시함수가 서로 다른 입력 값에 대해 동일한 해시테이블 주소를 반환하는것
        // 모든 입력 값에 대해 고유한 해시 값을 만드는 것은 불가능하며 충돌은 피할 수 없음.
        // 대표적인 충돌 해결방안으로 체이닝과 개방주소법이 있음.
        // 체이닝 -> 같은 인덱스를 가리킬경우 해당 인덱스값에 LinkedLIst를 사용해서 여러개를 동시에저장후 값을 탐색할때는 해당인덱스에서 찾음.
        // 체이닝의 경우 노드기반으로 문제를 해결하므로 C#은 열린주소법을 애용하는편.
        // 열린주소법의 경우 같은 인덱스에 적힌값이있다면 다음 주소에 값을 적음.

        // 개방주소법의 경우 
        // 장점 해시데이터를 사용하므로 추가적인 저장공간이 필요하지않음, 삽입 삭제시에 오버헤드ㅏㄱ ㅓㅈ긍ㅁ
        // 단점 헤시테이블에 데이터가많아질수록 탐색의 효율이 떨어짐
        // 단점해결 -> 해시테이블의 저장용량이 어느정도 찰경우 재해싱을 진행함 (통상 75%)
        // 재해싱 : 새로운 크기의 해시테이블을 새로만들고 데이터를 새로운 테이블로 옮겨줌

        static void Dictionary()
        {
            Dictionary<string,Item > dictionary = new Dictionary<string, Item> ();

            // ㅊ가
            dictionary.Add("초기공격아이템", new Item("초보자용 검", 20));
            dictionary.Add("초기방어아이템", new Item("초보자용 가죽갑옷", 30));
            dictionary.Add("전직아이템", new Item("용맹의 증명", 3));

            // 탐색
            Console.WriteLine(dictionary["전직아이템"].name);
            
            // 접근
            dictionary.Remove("전직아이템");
            if (dictionary.ContainsKey("초기아이템"))
            {
                Console.WriteLine("딕셔너리에 초기 아이템이 있음");
            }
        }

        static void Main(string[] args)
        {
            Program.Dictionary();
        }

        public class Item
        {
            public string name;
            public int weight;

            public Item(string name, int weight)
            {
                this.name = name;
                this.weight = weight;
            }
        }
    }
}